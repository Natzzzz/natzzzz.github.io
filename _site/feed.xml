<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title></title>
    <description>Malwares &amp; ctfs</description>
    <link>/</link>
    <atom:link href="/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Wed, 01 Sep 2021 23:36:21 +0200</pubDate>
    <lastBuildDate>Wed, 01 Sep 2021 23:36:21 +0200</lastBuildDate>
    <generator>Jekyll v4.2.0</generator>
    
      <item>
        <title>Core wars - your new favorite game</title>
        <description>&lt;p&gt;Last year while playing &lt;a href=&quot;http://rada.re/con&quot;&gt;r2con&lt;/a&gt; ctf, i saw some people playing an obscure assembly-like game I didn’t understand at all. It actually wasn’t assembly, it was Redcode, and the game was called Core War.&lt;/p&gt;

&lt;p&gt;Here’s how it works: two programs (called warriors) fight against each other in a small simulated memory space (called the core).&lt;/p&gt;

&lt;p&gt;Each round, the warriors execute one instruction until one of them can’t play anymore, for example because its instruction pointer got corrupted by the opponent.&lt;/p&gt;

&lt;p&gt;At the beginning, each warrior is loaded into the core at a random address. There is no absolute address, thus you won’t be able to specify a precise one, like 0x…… in the usual asm languages. The core is a sort of array, in which there is no beginning and no end. In fact, if we wanted to represent what the core looked like, it would rather look like a sort of pipe, or a sphere. For your warrior, the address where it currently is will be 0, the next one will be 1 and the previous will be -1, and so on.&lt;/p&gt;

&lt;p&gt;The format is &lt;source /&gt;, &lt;destination&gt;, like in x64 asm. Don&apos;t forget that, fellow x86 enthusiasts.&lt;/destination&gt;&lt;/p&gt;

&lt;p&gt;When you create your own warrior, there are 3 main strategies that you might use:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Rock&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;Rock warriors try to take as much addresses in the middle of the core (it is statistically more likely that the opponent will spawn around the middle), hoping that it’ll kill the other warrior quickly.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Paper&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;Unlike the rock strategy, this one is trying to survive as much as possible, not to quickly kill its opponent. The most usual way to do this is by writing in as many addresses as it can. Remember the &lt;em&gt;spl&lt;/em&gt; instruction will be very useful for this one.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Scissors&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;Here’s my fav one. It scans the core, trying to find occupied addresses. Once it finds an address where its opponent might be, it will bomb as much as it can around that address, hoping to kill it. Pretty cool, huh ?&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;opcodes&quot;&gt;Opcodes&lt;/h1&gt;

&lt;p&gt;As in every assembly language, you have a lot of different opcodes, and every one of them serves a different purpose. You can have a look at all of them &lt;a href=&quot;https://esolangs.org/wiki/Redcode#Instructions&quot;&gt;here&lt;/a&gt;. Some of them are also used in assembly, like mov, add, sub, mul, div, mod, jmp, jmz (equivalent to jz in asm), jmn (=jnz), cmp and nop.&lt;/p&gt;

&lt;p&gt;You’ve certainly already used most of the above opcodes, but if you take a closer look at the full list, you’ll see that the other half of these opcodes are completely unknown.&lt;/p&gt;

&lt;h3 id=&quot;dat&quot;&gt;dat&lt;/h3&gt;

&lt;p&gt;the &lt;em&gt;dat&lt;/em&gt; instruction kills the current task. One of the most useful ones out there.&lt;/p&gt;

&lt;h3 id=&quot;mov&quot;&gt;mov&lt;/h3&gt;

&lt;p&gt;The mov operation will copy the instruction from the source (operand A) to the destination (operand b).&lt;/p&gt;

&lt;p&gt;Have a look at a very (very) simple warrior called &lt;em&gt;The Imp&lt;/em&gt;. It only consists of a single instruction:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-assembly&quot;&gt;;name The Imp
mov 0, 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Yup, that’s it, nothing more.&lt;/p&gt;

&lt;p&gt;The explanation will be pretty straightforward: it just copies the instruction of the address where it is (then 0) to the address just next (1). To be more clear: it copies itself into the next address, which creates an infinite loop, as the core doesn’t have any beginning, nor end.&lt;/p&gt;

&lt;h3 id=&quot;add-sub-and-mul&quot;&gt;add, sub and mul&lt;/h3&gt;

&lt;p&gt;This will add what’s on the address at 4 to what’s in the address 2.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-assembly&quot;&gt;add 4, 2 ; adds what&apos;s on the address at 4 to what&apos;s on the address at 2. 
sub 3, 4 ; Same thing as the add, but it&apos;s a substraction. Nothing really hard in there. 
mul 2, 1 ; oh, really ? I&apos;m sure you guessed what this is about. 
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;div&quot;&gt;div&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;div&lt;/em&gt; works the same way as the above, but there’s a little trick with it: if the result is a float, it will be rounded down: so if you get 3.9, it will be 3.&lt;/p&gt;

&lt;p&gt;Another thing to know is that you can’t divide by 0. If you still do it, your program will stop its execution. Don’t divide by 0, then.&lt;/p&gt;

&lt;h3 id=&quot;mod&quot;&gt;mod&lt;/h3&gt;

&lt;p&gt;If you don’t already know modulo (pretty sure it isn’t the case if you’re reading this), it will divide the first argument by the second, and store the remainder in the destination.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-assembly&quot;&gt;mod 7, 5
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;jmp-jmz-jmn-djn&quot;&gt;jmp, jmz, jmn, djn&lt;/h3&gt;

&lt;p&gt;The jmp instruction is used to move to another address (remember, we only use relative addresses in redcode). The specificity is that you only need to add the &lt;source /&gt; address. You still can put some code at the &lt;destination&gt;, but i guess it&apos;ll just be ignored.&lt;/destination&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-assembly&quot;&gt;jmp 4 ; -&amp;gt; jump 4 addresses after the current one
mov 2, -1 ; -&amp;gt; move &quot;dat 9&quot; to -1 -&amp;gt; what was jmp 4 until now
jmp -1 ; jump to the precedent address
dat 9 ; tries to kill the process at 9
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;spl&quot;&gt;spl&lt;/h2&gt;

&lt;p&gt;I had never seen such an opcode before playing this game. It would be actually totally useless in other situations, because we always have full control over the instruction pointer. However, due to corewars being a turn to turn game, if you want to do two things in the same time, you’ll have either to do it manually, (i.e. writing one line per process), OR use the &lt;em&gt;spl&lt;/em&gt; opcode.&lt;/p&gt;

&lt;p&gt;The &lt;em&gt;spl&lt;/em&gt; opcode is used to create separate processes, so that your code does two separate things, one at a time.&lt;/p&gt;

&lt;pre&gt;
                                ┌───┐  ┌───► ...
                          ┌────►│spl├──┤
                  ┌───┐   │     └───┘  └───► ...
  ───── single ───┤spl├───┤
        process   └───┘   │     ┌───┐  ┌───► ...
                          └────►│spl├──┤
                                └───┘  └───► ...
&lt;/pre&gt;

&lt;p&gt;Obviously, it’ll only execute one instruction at a time, but it will alternate between its different processes.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-assembly&quot;&gt;warrior 1 ; -&amp;gt; Process A
warrior 2 ; -&amp;gt; ...
warrior 1 ; -&amp;gt; Process B
warrior 2 ; -&amp;gt; ...
warrior 1 ; -&amp;gt; Process A
warrior 2 ; -&amp;gt; ...
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;nop&quot;&gt;nop&lt;/h3&gt;

&lt;p&gt;the nop, as most of you already know it, is pretty self-explanatory: NO-Operation. It just does absolutely nothing. wow.&lt;/p&gt;

&lt;p&gt;Great, now you should know everything about redcode (well, actually not. There’s a lot more to know, but you already know the basics)&lt;/p&gt;

&lt;p&gt;If you’d like to know more about redcode and core wars in general, you definitely have to check the links below.&lt;/p&gt;

&lt;p&gt;Hope you liked that post, don’t hesitate to hit me up if you have suggestions, or if i could help you in any way.&lt;/p&gt;

&lt;h1 id=&quot;ressources--references&quot;&gt;Ressources / references&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://vyznev.net/corewar/guide.html&quot;&gt;The beginner’s guide to redcode &lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://www.koth.org/info/corewars_for_dummies/dummies.html&quot;&gt;Koth.org’s corewars for dummies &lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Core_War&quot;&gt;Wikipedia - Core wars&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://www.corewar.io/&quot;&gt;Corewar.io, to practice online&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Wed, 01 Sep 2021 14:00:00 +0200</pubDate>
        <link>/misc/2021/09/01/coreWarsIntro.html</link>
        <guid isPermaLink="true">/misc/2021/09/01/coreWarsIntro.html</guid>
        
        
        <category>misc</category>
        
      </item>
    
      <item>
        <title>Patching a binary using r2</title>
        <description>&lt;p&gt;When doing binary exploitation challenges, you can’t always just trick the program to make him do what you want it to do. Sometimes, it’s easier and faster to change it directly in order to get the result we expect.&lt;/p&gt;

&lt;p&gt;In this little tutorial, I’ll teach you how to patch an ELF binary with radare2 , an awesome reverse engineering framework that is sooo useful when playing ctfs, doing malware analysis or really anything that involves assembly at some point.&lt;/p&gt;

&lt;p&gt;The sample I’ll use for this tutorial is from the PicoCTF 2018.&lt;/p&gt;

&lt;p&gt;Always start by running your binary, so that you understand what’s going on.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/patchingBinaryR2_1.png&quot; alt=&quot;&quot; /&gt; 
Sooo, it prints the name of the challenge and the string “calculating key…”, then it waits for a second before to print the last line. Strange, right ? Let’s open r2 now, to see what’s happening inside.&lt;br /&gt;
&lt;img src=&quot;/assets/images/patchingBinaryR2_2.png&quot; alt=&quot;&quot; /&gt;
Use the aaa command to analyze your binary. It will detect and analyze the functions, the strings and pretty much everything inside of the program, to make it easier to go through it in our analysis. Then, use the command afl to list all the functions. You’ll see the main function, which is the spine of our program, and from which we’ll see most of the functions that will be called. We have to go to that main function, now that we know it exists. To do so, we’ll seek to that place, using the letter S, as shown below:&lt;br /&gt;
&lt;img src=&quot;/assets/images/patchingBinaryR2_3.png&quot; alt=&quot;&quot; /&gt;
I also printed the disas of that main function, to globally understand the flow of the program, and to see what other functions are called. With that disassembly, we can understand what the problem is: the amount of time that is given by the sym.set_timer function is too small, and the program stops its execution before that the sym.print_flag function (our objective) could be called.&lt;br /&gt;
Now that we understood what the problem was, I think about two ways to patch it, in order to get the output of the print_flag function. Of course, you could use gdb and redirect the instruction pointer directly to that function, but we only want to use r2 here, because we love it, right ?&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;The first way would be to seek to the set_timer function and change directly the time that is given to the timer, which is only one second for now, and try to make it bigger.&lt;/li&gt;
  &lt;li&gt;The second way would be to just nop out the set_timer function, so that when the instruction pointer comes to the address 0x00400845, It just won’t do anything and continue. That’s what we’re going to do.
Using a veeeeery great functionality of r2, we’ll nop everything that is on the address 0x00400845, as explained before.&lt;br /&gt;
&lt;img src=&quot;/assets/images/patchingBinaryR2_4.png&quot; alt=&quot;&quot; /&gt;
Now, we have our target (0x00400845), we just have to go right here, I just printed the disas of that address to be sure it was the right one, and now it’s time to patch, but first, we have to reopen r2 in write mode ! To do so, use the command oo+, and if you don’t have any output, you’re good to go.
&lt;img src=&quot;/assets/images/patchingBinaryR2_5.png&quot; alt=&quot;&quot; /&gt;
This magic command is the wao nop I used in the second line. It writes over your opcode with nops, which is exactly what we want to do.&lt;br /&gt;
To be sure everything is ok, re-print the disassembly of our address, aaaaand, it worked. Great ! Now, just quit (command q) and it’s time to see if what we did worked.
&lt;img src=&quot;/assets/images/patchingBinaryR2_6.png&quot; alt=&quot;&quot; /&gt;
Whooo ! It still takes a few seconds before the flag is printed, but it works and we get the flag !&lt;br /&gt;
For further documentation, you could read &lt;a href=&quot;https://r2wiki.readthedocs.io/en/latest/options/w/wao-op/&quot;&gt;this&lt;/a&gt;, and more globally &lt;a href=&quot;https://radare.gitbooks.io/radare2book/content/&quot;&gt;the documentation of r2&lt;/a&gt;, it’s a great ressource if you need to get better at reverse engineering. Have fun !&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Tue, 22 Dec 2020 13:00:00 +0100</pubDate>
        <link>/reversing/ctfs/2020/12/22/patchingBinaryUsingR2.html</link>
        <guid isPermaLink="true">/reversing/ctfs/2020/12/22/patchingBinaryUsingR2.html</guid>
        
        
        <category>reversing</category>
        
        <category>ctfs</category>
        
      </item>
    
  </channel>
</rss>
